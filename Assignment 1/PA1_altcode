PROGRAM:
ADDI X0,XZR,#0       //address for the start of the array
ADDI X1,XZR,#100     //length of the array
BL FILL             //branch and link to fill
DUMP
B INSERTIONSORT      //branch to insertionsort


FILL:
ADDI X9,X0,#0        //x9 = x0
ADDI X10,X1,#0       //x10 = x1
LOOP:
SUBI X10,X10,#1      //X1 = X1-1
STUR X10,[X9,#0]     //store the value in X1 to the spot in the array
ADDI X9,X9,#8         //X9++
CBNZ X10,LOOP         //if not zero branch to loop
BR LR


INSERTSORTEDPOS:
SUBI SP,SP,#32       //SUBTRACt FROM THE STACK
STUR X19,[SP,#24]    //store value in x19
STUR X20,[SP,#16]    // store value in x20
STUR X21,[SP,#8]     //store value in x21
STUR LR,[SP,#0]         //store the link register
ADDI X19,X0,#0       //X19 = X0
ADDI X20,X1,#0          //X20 = X1

LSL X9,X1,#3         //X9 = INDEX OF ELEMENT8
ADD X9,X0,X9         //X9 = INDEX OF ELEMENT8 + INDEX OF ARRAY
LDUR X1,[X9,#0]      //X1 = ARR[IND OF ELEMENT8 + IND OF ARRAY]
ADDI X21,X1,#0       //X21 = VALUE LOADED IN LAST LINE

BL FINDSORTEDPOS
ADDI X2,X20,#0       //X2 = INDEX OF THE ELEMENT
ADDI X1,X0,#0        //X1 = RETURN FROM FINDSORTEDPOS
ADDI X0,X19,#0       //X0 = INDEX OF THE ARRAY

BL SHIFTRIGHT
LSL X1,X1,#3         //X1 = X18
ADD X1,X0,X1         //X1 = X1 + ADDR OF ARRAY
STUR X21,[X1,#0]     //ARR[X1] = X1
LDUR LR,[SP,#0]       //RESTORE THE LINK REGISTER
LDUR X21,[SP,#8]      //RESTORE X21
LDUR X20,[SP,#16]     //RESTORE X20
LDUR X19,[SP,#24]     //RESTORE X19
ADDI SP,SP,#32          //ADD BACK TO THE STACK
BR LR



FINDSORTEDPOS:
SUBI X9,X0,#8        //X9 = IND OF ARRAY - 8
LSL X10,X2,#3        //X10 = IND OF ELEMENT 8
ADD X10,X0,X10       //X10 = IND OF ELEMENT8 + IND OF ARRAY
LOOP2:
ADDI X9,X9,#8        //X9 = X9 + 8
LDUR X11,[X9,#0]     //X11 = ARR[X9]
SUBS XZR,X11,X1     //SET FLAGS FOR X11 - X1
B.GE FINISHED
SUB X12,X9,X10       //X12 = CURRENT INDEX - STOPPING INDEX
CBNZ X12,LOOP2       //BRANCH TO LOOP2 IF WE ARE NOT AT THE LAST INDEX
FINISHED:

SUB X9,X9,X0         //SUBTRACT THE INDEX OF THE ARRAY FROM X9
LSR X0,X9,#3         //SHIFT X9 BACK AND RETURN THE INDEX
BR LR


SHIFTRIGHT:
SUBI X9,X2,#0        //X9 = INDEX OF ELEMENT TO OVERWRITE
LOOP3:
SUBI X9,X9,#1        //X9 = X9 - 1
LSL X10,X9,#3        //X10 = X9*8
ADD X10,X0,X10       //X10 = ADDR OF ARRAY + X10
LDUR X11,[X10,#0]    // X11 = ARR[X10]
STUR X11,[X10,#8]    //ARR[X10 + 8] = X11
SUB X12,X9,X1        //X12 = X9 - X1
CBNZ X12,LOOP3
BR LR


INSERTIONSORT:
SUBI X2,X1,#1        //X2 = LENGTH -1
ADDI X1,X0,#0        //X1 = X0
LOOP1:
ADDI X1,X1,#1        //X1++ 
SUBI SP,SP,#24       //SUBTRACT FOR THE STACK
STUR X0,[SP,#16]     //STORE X0 FOR THE PROCEDURE CALL
STUR X1,[SP,#8]      //STORE X1 FOR THE PROCEDURE CALL
STUR X2,[SP,#0]      //STORE X2 FOR THE PROCEDURE CALL
BL INSERTSORTEDPOS
LDUR X2,[SP,#0]      //LOAD X2 AFTER THE PROCEDURE CALL
LDUR X1,[SP,#8]      //LOAD X1 AFTER THE PROCEDURE CALL
LDUR X0,[SP,#16]     //LOAD X0 AFTER THE PROCEDURE CALL
ADDI SP,SP,#24       //ADD BACK TO THE STACK
SUB X9,X1,X2         //X9 = X1 - LENGTH - 1
CBNZ X9,LOOP1        //BRANCH TO LOOP IF X9 NOT ZERO

DUMP